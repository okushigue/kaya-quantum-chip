# kaya_qkd_bb84_fixed.py
import random
import numpy as np
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
import hashlib
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple, Optional

class KayaQKDBB84:
    def __init__(self, n_bits: int = 100, channel_loss: float = 0.1, 
                 detector_eff: float = 0.9, dark_count_rate: float = 1e-6,
                 include_realistic_noise: bool = True):
        self.n_bits = n_bits
        self.channel_loss = channel_loss
        self.detector_eff = detector_eff
        self.dark_count_rate = dark_count_rate
        self.include_realistic_noise = include_realistic_noise
        self.simulator = AerSimulator()
        self._results = {}
        print(f"üîê Kaya QKD BB84 Protocol | Bits: {n_bits}, Loss: {channel_loss:.1%}, Efficiency: {detector_eff:.1%}")
    
    def _apply_realistic_noise(self, quantum_circuit: QuantumCircuit, bit: int, basis: int) -> QuantumCircuit:
        """Aplica ru√≠dos realistas encontrados em implementa√ß√µes pr√°ticas"""
        if not self.include_realistic_noise:
            return quantum_circuit
            
        # Ru√≠do de prepara√ß√£o de estado (0.5-1.5%)
        if random.random() < 0.01:
            quantum_circuit.x(0)  # Flip bit com pequena probabilidade
        
        # Ru√≠do de fase (imperfei√ß√µes no interfer√¥metro)
        if random.random() < 0.015:
            phase_error = random.gauss(0, 0.05)  # Pequeno desvio de fase
            quantum_circuit.rz(phase_error, 0)
        
        # Ru√≠do de desalinhamento de bases (0.5-2%)
        if random.random() < 0.01:
            misalignment = random.gauss(0, 0.02)
            quantum_circuit.rz(misalignment, 0)
        
        return quantum_circuit
    
    def _apply_channel_effects(self, quantum_state: int) -> Optional[int]:
        """Aplica efeitos realistas do canal qu√¢ntico"""
        # Perda no canal
        if random.random() < self.channel_loss:
            return None
        
        # Dark counts (falsas detec√ß√µes)
        if random.random() < self.dark_count_rate:
            return random.randint(0, 1)
        
        # Efici√™ncia do detector
        if random.random() > self.detector_eff:
            return None
        
        # Ru√≠do de detec√ß√£o (1-3% de erro de leitura)
        if self.include_realistic_noise and random.random() < 0.02:
            return 1 - quantum_state  # Flip do bit
        
        return quantum_state
    
    def _create_quantum_state(self, bit: int, basis: int) -> QuantumCircuit:
        """Cria o estado qu√¢ntico baseado no bit e base escolhidos"""
        qc = QuantumCircuit(1, 1)
        
        # Prepara√ß√£o do estado
        if bit == 1:
            qc.x(0)
        
        # Aplica√ß√£o da base
        if basis == 1:  # Base X (Hadamard)
            qc.h(0)
        
        # Aplica ru√≠do realista
        qc = self._apply_realistic_noise(qc, bit, basis)
        
        return qc
    
    def _measure_quantum_state(self, qc: QuantumCircuit, basis: int) -> int:
        """Mede o estado qu√¢ntico na base especificada"""
        # Aplica a base de medi√ß√£o
        if basis == 1:  # Base X
            qc.h(0)
        
        # Ru√≠do de medi√ß√£o (detectores imperfeitos)
        if self.include_realistic_noise and random.random() < 0.01:
            qc.x(0)  # Pequeno erro de medi√ß√£o
        
        qc.measure(0, 0)
        
        # Executa a simula√ß√£o
        job = self.simulator.run(qc, shots=1, memory=True)
        result = job.result().get_memory()[0]
        
        return int(result)
    
    def run_protocol(self) -> Dict:
        """Executa o protocolo BB84 completo"""
        print("\nüì° Executing BB84 Quantum Key Distribution Protocol...")
        
        # Gera√ß√£o aleat√≥ria de bits e bases
        alice_bits = [random.randint(0, 1) for _ in range(self.n_bits)]
        alice_bases = [random.randint(0, 1) for _ in range(self.n_bits)]  # 0=Z, 1=X
        bob_bases = [random.randint(0, 1) for _ in range(self.n_bits)]
        
        raw_key_alice = []
        raw_key_bob = []
        detected_indices = []
        
        print("   üîÑ Transmitting photons through quantum channel...")
        
        for i in range(self.n_bits):
            # Alice prepara o estado qu√¢ntico
            qc = self._create_quantum_state(alice_bits[i], alice_bases[i])
            
            # Bob mede o estado
            try:
                bob_bit = self._measure_quantum_state(qc, bob_bases[i])
                
                # Aplica efeitos do canal
                final_bit = self._apply_channel_effects(bob_bit)
                
                if final_bit is not None:
                    raw_key_alice.append(alice_bits[i])
                    raw_key_bob.append(final_bit)
                    detected_indices.append(i)
                    
            except Exception as e:
                continue
        
        # Estat√≠sticas de transmiss√£o
        transmitted = self.n_bits
        detected = len(raw_key_alice)
        detection_rate = detected / transmitted if transmitted > 0 else 0
        
        print(f"   üìä Transmission Statistics:")
        print(f"      ‚Ä¢ Photons transmitted: {transmitted}")
        print(f"      ‚Ä¢ Photons detected: {detected} ({detection_rate:.1%})")
        print(f"      ‚Ä¢ Channel efficiency: {(1-self.channel_loss)*self.detector_eff:.1%}")
        
        # Sincroniza√ß√£o de bases (sifting)
        sifted_alice = []
        sifted_bob = []
        matching_bases_indices = []
        
        for i in range(len(raw_key_alice)):
            idx = detected_indices[i]
            if alice_bases[idx] == bob_bases[idx]:
                sifted_alice.append(raw_key_alice[i])
                sifted_bob.append(raw_key_bob[i])
                matching_bases_indices.append(idx)
        
        sifting_efficiency = len(sifted_alice) / detected if detected > 0 else 0
        
        print(f"   üîç Sifting Process:")
        print(f"      ‚Ä¢ Bits after sifting: {len(sifted_alice)}")
        print(f"      ‚Ä¢ Sifting efficiency: {sifting_efficiency:.1%}")
        
        # C√°lculo do QBER (Quantum Bit Error Rate)
        if len(sifted_alice) > 0:
            errors = sum(a != b for a, b in zip(sifted_alice, sifted_bob))
            qber = errors / len(sifted_alice)
            
            # Estimativa de eavesdropping
            security_status, security_message = self._estimate_security(qber)
            
            print(f"   üõ°Ô∏è  Security Analysis:")
            print(f"      ‚Ä¢ Errors detected: {errors}/{len(sifted_alice)}")
            print(f"      ‚Ä¢ QBER: {qber:.3%}")
            print(f"      ‚Ä¢ Secure threshold: < 11.0%")
            print(f"      ‚Ä¢ Status: {security_message}")
            
            # Amplifica√ß√£o de privacidade
            final_key = self._privacy_amplification(sifted_alice)
            key_entropy = self._calculate_key_entropy(final_key)
            
            # Armazena resultados
            self._results = {
                'transmitted_bits': transmitted,
                'detected_bits': detected,
                'detection_rate': detection_rate,
                'sifted_bits': len(sifted_alice),
                'sifting_efficiency': sifting_efficiency,
                'errors': errors,
                'qber': qber,
                'secure': security_status,
                'security_message': security_message,
                'final_key': final_key,
                'key_length': len(final_key),
                'key_entropy': key_entropy,
                'alice_bases': alice_bases,
                'bob_bases': bob_bases,
                'matching_bases_count': len(matching_bases_indices),
                'noise_included': self.include_realistic_noise
            }
            
            # Exibe resumo da chave
            self._display_key_summary(final_key)
            
            return self._results
        else:
            error_msg = "No bits survived the quantum channel and detection process"
            print(f"   ‚ùå {error_msg}")
            return {'error': error_msg, 'secure': False}
    
    def _estimate_security(self, qber: float) -> Tuple[bool, str]:
        """Estima a seguran√ßa baseado no QBER"""
        if qber < 0.02:
            return True, "‚úÖ HIGHLY SECURE (QBER < 2%)"
        elif qber < 0.05:
            return True, "‚úÖ SECURE (QBER < 5%)"
        elif qber < 0.08:
            return True, "‚ö†Ô∏è  MARGINALLY SECURE (QBER < 8%)"
        elif qber < 0.11:
            return True, "üö® BORDERLINE (QBER < 11%)"
        else:
            return False, "‚ùå INSECURE - Possible eavesdropping detected"
    
    def _privacy_amplification(self, sifted_key: List[int]) -> str:
        """Aplica amplifica√ß√£o de privacidade para reduzir informa√ß√£o do eavesdropper"""
        if not sifted_key:
            return ""
        
        # Converte lista de bits para string
        key_str = ''.join(map(str, sifted_key))
        
        # Aplica hash SHA-256 para amplifica√ß√£o de privacidade
        hashed = hashlib.sha256(key_str.encode()).hexdigest()
        
        # Converte hexadecimal para bin√°rio (apenas primeiros 128 bits para chave AES-128)
        binary_key = bin(int(hashed[:32], 16))[2:].zfill(128)
        
        return binary_key
    
    def _calculate_key_entropy(self, key: str) -> float:
        """Calcula a entropia da chave final"""
        if not key:
            return 0.0
        
        # Conta a frequ√™ncia de 0s e 1s
        count_0 = key.count('0')
        count_1 = key.count('1')
        total = len(key)
        
        # Calcula entropia de Shannon
        p0 = count_0 / total
        p1 = count_1 / total
        
        entropy = 0.0
        if p0 > 0:
            entropy -= p0 * np.log2(p0)
        if p1 > 0:
            entropy -= p1 * np.log2(p1)
        
        return entropy
    
    def _display_key_summary(self, final_key: str):
        """Exibe resumo da chave gerada"""
        if not final_key:
            return
        
        print(f"   üîë Final Key Summary:")
        print(f"      ‚Ä¢ Key length: {len(final_key)} bits")
        print(f"      ‚Ä¢ Key entropy: {self._results['key_entropy']:.3f} bits/bit")
        print(f"      ‚Ä¢ First 32 bits: {final_key[:32]}")
        print(f"      ‚Ä¢ Last 32 bits: {final_key[-32:]}")
        
        # Verifica aleatoriedade
        if self._results['key_entropy'] > 0.98:
            randomness = "EXCELLENT"
        elif self._results['key_entropy'] > 0.95:
            randomness = "HIGH"
        elif self._results['key_entropy'] > 0.90:
            randomness = "MODERATE"
        else:
            randomness = "LOW"
            
        print(f"      ‚Ä¢ Randomness quality: {randomness}")
        print(f"      ‚Ä¢ Realistic noise: {'ENABLED' if self.include_realistic_noise else 'DISABLED'}")
    
    def run_multiple_trials(self, n_trials: int = 10) -> Dict:
        """Executa m√∫ltiplos trials para an√°lise estat√≠stica"""
        print(f"\nüìä Running {n_trials} statistical trials...")
        
        results = []
        secure_count = 0
        qber_values = []
        key_lengths = []
        detection_rates = []
        
        for trial in range(n_trials):
            print(f"   Trial {trial + 1}/{n_trials}...")
            result = self.run_protocol()
            
            if 'qber' in result:
                results.append(result)
                qber_values.append(result['qber'])
                key_lengths.append(result['key_length'])
                detection_rates.append(result['detection_rate'])
                
                if result['secure']:
                    secure_count += 1
        
        if results:
            security_probability = secure_count / n_trials
            avg_qber = np.mean(qber_values)
            avg_key_length = np.mean(key_lengths)
            avg_detection_rate = np.mean(detection_rates)
            
            stats = {
                'trials_completed': n_trials,
                'security_probability': security_probability,
                'average_qber': avg_qber,
                'average_key_length': avg_key_length,
                'average_detection_rate': avg_detection_rate,
                'qber_std': np.std(qber_values),
                'reliability': f"{security_probability:.1%} secure executions",
                'detailed_results': results
            }
            
            print(f"\n   üìà Statistical Summary:")
            print(f"      ‚Ä¢ Security probability: {security_probability:.1%}")
            print(f"      ‚Ä¢ Average QBER: {avg_qber:.3%} ¬± {np.std(qber_values):.3%}")
            print(f"      ‚Ä¢ Average detection rate: {avg_detection_rate:.1%}")
            print(f"      ‚Ä¢ Average key length: {avg_key_length:.0f} bits")
            print(f"      ‚Ä¢ Realistic noise: {'ENABLED' if self.include_realistic_noise else 'DISABLED'}")
            
            return stats
        else:
            return {'error': 'No successful trials'}
    
    def plot_performance(self, stats: Dict):
        """Gera gr√°ficos de performance"""
        if 'detailed_results' not in stats:
            return
        
        results = stats['detailed_results']
        qbers = [r['qber'] for r in results]
        detection_rates = [r['detection_rate'] for r in results]
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
        
        # Gr√°fico do QBER
        ax1.plot(range(len(qbers)), qbers, 'bo-', alpha=0.7, label='QBER')
        ax1.axhline(y=0.02, color='green', linestyle='--', alpha=0.7, label='Highly Secure (2%)')
        ax1.axhline(y=0.05, color='orange', linestyle='--', alpha=0.7, label='Secure (5%)')
        ax1.axhline(y=0.11, color='red', linestyle='--', label='Security threshold (11%)')
        ax1.set_xlabel('Trial Number')
        ax1.set_ylabel('QBER')
        ax1.set_title('QBER Evolution Across Trials')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # Gr√°fico das taxas de detec√ß√£o
        ax2.plot(range(len(detection_rates)), detection_rates, 'go-', alpha=0.7, label='Detection Rate')
        ax2.axhline(y=stats['average_detection_rate'], color='red', linestyle='--', 
                   label=f'Average: {stats["average_detection_rate"]:.1%}')
        ax2.set_xlabel('Trial Number')
        ax2.set_ylabel('Detection Rate')
        ax2.set_title('Photon Detection Rate Across Trials')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('qkd_performance_analysis.png', dpi=150, bbox_inches='tight')
        print("   üíæ Performance plot saved as 'qkd_performance_analysis.png'")
        plt.close()  # Evita o warning de non-interactive
    
    def simulate_eavesdropping_attack(self, eavesdrop_probability: float = 0.3):
        """Simula um ataque de eavesdropping (intercept-and-resend)"""
        print(f"\nüïµÔ∏è  Simulating Eavesdropping Attack (intercept probability: {eavesdrop_probability:.0%})...")
        
        # Backup da configura√ß√£o original
        original_noise_setting = self.include_realistic_noise
        self.include_realistic_noise = False  # Desabilita ru√≠do para isolar o ataque
        
        alice_bits = [random.randint(0, 1) for _ in range(self.n_bits)]
        alice_bases = [random.randint(0, 1) for _ in range(self.n_bits)]
        bob_bases = [random.randint(0, 1) for _ in range(self.n_bits)]
        
        raw_key_alice = []
        raw_key_bob = []
        detected_indices = []
        eavesdrop_count = 0
        
        for i in range(self.n_bits):
            # Eve intercepta com probabilidade especificada
            if random.random() < eavesdrop_probability:
                eavesdrop_count += 1
                # Eve escolhe uma base aleat√≥ria para medir
                eve_basis = random.randint(0, 1)
                
                # Eve mede o estado
                qc_eve = self._create_quantum_state(alice_bits[i], alice_bases[i])
                eve_bit = self._measure_quantum_state(qc_eve, eve_basis)
                
                # Eve reenvia o estado na base que ela mediu
                qc_resent = self._create_quantum_state(eve_bit, eve_basis)
            else:
                # Sem eavesdropping - estado original
                qc_resent = self._create_quantum_state(alice_bits[i], alice_bases[i])
            
            # Bob mede o estado (que pode ter sido modificado por Eve)
            bob_bit = self._measure_quantum_state(qc_resent, bob_bases[i])
            final_bit = self._apply_channel_effects(bob_bit)
            
            if final_bit is not None:
                raw_key_alice.append(alice_bits[i])
                raw_key_bob.append(final_bit)
                detected_indices.append(i)
        
        # Processamento normal
        sifted_alice = []
        sifted_bob = []
        
        for i in range(len(raw_key_alice)):
            idx = detected_indices[i]
            if alice_bases[idx] == bob_bases[idx]:
                sifted_alice.append(raw_key_alice[i])
                sifted_bob.append(raw_key_bob[i])
        
        if len(sifted_alice) > 0:
            errors = sum(a != b for a, b in zip(sifted_alice, sifted_bob))
            qber = errors / len(sifted_alice)
            
            security_status, security_message = self._estimate_security(qber)
            
            print(f"   üïµÔ∏è  Eavesdropping Results:")
            print(f"      ‚Ä¢ Eavesdropping attempts: {eavesdrop_count}/{self.n_bits} ({eavesdrop_count/self.n_bits:.1%})")
            print(f"      ‚Ä¢ Induced QBER: {qber:.3%}")
            print(f"      ‚Ä¢ Security status: {security_message}")
            
            # Restaura configura√ß√£o original
            self.include_realistic_noise = original_noise_setting
            
            return {
                'eavesdrop_probability': eavesdrop_probability,
                'eavesdrop_attempts': eavesdrop_count,
                'induced_qber': qber,
                'secure': security_status,
                'detected_bits': len(raw_key_alice),
                'sifted_bits': len(sifted_alice)
            }
        
        # Restaura configura√ß√£o original
        self.include_realistic_noise = original_noise_setting
        return {'error': 'No successful detections during eavesdropping simulation'}
    
    def get_detailed_report(self) -> Dict:
        """Retorna relat√≥rio detalhado dos resultados"""
        return self._results

# Exemplo de uso avan√ßado
if __name__ == "__main__":
    print("=" * 60)
    print("üî¨ Kaya QKD BB84 - Advanced Quantum Cryptography Simulator")
    print("=" * 60)
    
    # Teste com ru√≠do realista
    print("\n1. TESTE COM RU√çDO REALISTA:")
    qkd_realistic = KayaQKDBB84(
        n_bits=256, 
        channel_loss=0.2, 
        detector_eff=0.85,
        include_realistic_noise=True
    )
    result1 = qkd_realistic.run_protocol()
    
    # Teste sem ru√≠do (ideal)
    print("\n2. TESTE IDEAL (SEM RU√çDO):")
    qkd_ideal = KayaQKDBB84(
        n_bits=256,
        channel_loss=0.1,
        detector_eff=0.95,
        include_realistic_noise=False
    )
    result2 = qkd_ideal.run_protocol()
    
    # Teste estat√≠stico
    print("\n3. AN√ÅLISE ESTAT√çSTICA:")
    stats = qkd_realistic.run_multiple_trials(n_trials=5)
    
    # Gera gr√°ficos
    qkd_realistic.plot_performance(stats)
    
    # Simula√ß√£o de ataque
    print("\n4. SIMULA√á√ÉO DE ATAQUE EAVESDROPPING:")
    attack_result = qkd_realistic.simulate_eavesdropping_attack(eavesdrop_probability=0.4)
    
    print("\n" + "=" * 60)
    print("‚úÖ Kaya QKD BB84 Simulation Completed Successfully!")
    print("=" * 60)
